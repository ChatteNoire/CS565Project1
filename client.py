# Victoria Van
# CS 565
# September 14, 2018
# Professor T. Mukherjee
# Project 1: Diffie-Hellman *CLIENT*
# --------------------------------------
# Description: 
# This program is the client socket that connects and listens to a server
# socket.  The client and server agree on a shared keys 'p' and 'g'
# with the server. Client randomly generates prime 'p1' which is used
# to get Pk1.  The client and server swap public keys and use their own
# private keys to generate the encryption key. The server encrypts the
# input file and sends it the client, which decrypts it with the
# generated key.  The result should be the same as the original input file.
# --------------------------------------
# Code template provided by Professor T.  

import socket                       # socket library
import sympy                        # random prime generator library
from Crypto.Cipher import AES       # AES encryption library
import hashlib                      # hash library (MD5)
import base64                       # binary to plain text library

def client():
    """
    Client code for connecting to server and receiving file from server.
    Right now we assume both work on localhost.
    """
    s = socket.socket()   # Create a socket object
    host = socket.gethostname()  # Get local machine name
    port = 63000   # Make sure that client pings server on correct port

    s.connect((host, port))  # connect with the server
    s.send(b"Hello server!")  # communicate with the server

    # Agree on 'p' and 'g' primes
    p = s.recv(1024)    # socket will read at most 1024 bytes, get 'p' prime
    g = s.recv(1024)    # receive 'g' prime
    print(p)
    print(g)
    p = int.from_bytes(p, byteorder='big')  # Bytes-> int (big endian) of p
    g = int.from_bytes(g, byteorder='big')  # Bytes-> int (big endian) of g
    print('p = ',p) # debugging p
    print('g = ',g) # debugging g

    # Generate secret prime 'p1'
    p1 = sympy.randprime(2,2000) # random 'p1' prime (secret)
    while p1 == p:   # p1 != p
        p1 = sympy.randprime(2,2000) # random 'p1' prime (secret)
    
    print('p1 = ',p1)   # debugging p1 (only client knows)

    # Generate public key Pk1 = g^(p1) mod p
    Pk1 = pow(g, p1, p) #pow(x,y[,z]) computers g^(y)mod(z) more efficiently
    print ('Pk1 = ',Pk1)    # Public key 1 generated by client

    # Send Pk1 to Server (1)
    s.sendall(Pk1.to_bytes(16,'big')) # convert to Bytes, big endian

    # Receive Pk2 from Server (2)
    Pk2 = s.recv(1024)
    Pk2 = int.from_bytes(Pk2, byteorder='big')  # convert Pk2 bytes -> int
    print('Pk2 = ',Pk2)
    
    # Get Server Shared Key (3)
    Pk2_p1 = pow(Pk2, p1)
    Pk2_p1 = Pk2_p1 % p
    print('\nShared DH key: ', Pk2_p1)
    
    #encrypted = bytearray(b'')
    encrypted = b''
    with open('received_file.txt', 'wb') as f: # formerly wb
       # while True:
        #    print('Receiving data...')
           # data = s.recv(1024) # formerly 1024

        #    print('data = ', (data))
        #    if not data:
          #      break
           # encrypted += data

        
        print('Receiving data...')
        data = s.recv(1024) # formerly 1024

        print('data = ', (data))
        #if not data:
         #   break
        encrypted += data

        s.send(b'Transfer completed!\n')

        # Generate MD5 hash of received encrypted file    
        md5check = hashlib.md5(encrypted).hexdigest()
        print('\nEncrypted data received: ',encrypted)
        print('\nMD5 Hash: ',md5check)

        # Receive MD5 hash from server to check
        md5hashCompare = s.recv(1024) # receive MD5 hash
        if md5hashCompare != md5check:  # check if MD5 hash from server matches with client's
            print('\nMD5 hashes DO NOT match!!!\n')     # hashes do NOT match
        else:
            print('\nMD5 hashes match.\n')        # hashes match!
        
        # Decrypt file
        Pk2_p1 = Pk2_p1.to_bytes(16,'big')  # convert Pk2_p1 to bytes, big endian
        cipher = AES.new(Pk2_p1, AES.MODE_ECB)  # create new AES cipher
        plaintext = cipher.decrypt(base64.b64decode(encrypted)) # decrypt encrypted file
        print('Plainttext: ',plaintext.decode("utf-8")) # VV note: removed .strip()

        # write data to a file
        f.write(plaintext.lstrip()) # lstrip removes whitespace before text

    f.close() # close output file
    print('Successfully obtained file from server')
    s.close()   # close socket connection
    print('Connection closed') 

if __name__=='__main__':
    client()
